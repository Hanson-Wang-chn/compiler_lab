# 运算符识别测试

## 功能说明

本测试程序专门测试词法分析器对C语言运算符的识别，重点验证**最长匹配原则**的实现。

## 测试内容

### 1. 单字符运算符
- `+` (加法)
- `-` (减法)
- `*` (乘法)
- `/` (除法)
- `%` (取模)
- `=` (赋值)
- `<` (小于)
- `>` (大于)
- `!` (逻辑非)
- `&` (按位与)
- `|` (按位或)
- `^` (异或)
- `~` (按位非)

### 2. 双字符运算符
- `++` (自增)
- `--` (自减)
- `+=`, `-=`, `*=`, `/=`, `%=` (复合赋值)
- `==` (相等)
- `!=` (不等)
- `<=` (小于等于)
- `>=` (大于等于)
- `<<` (左移)
- `>>` (右移)
- `&&` (逻辑与)
- `||` (逻辑或)
- `->` (指针访问)

### 3. 三字符运算符
- `<<=` (左移赋值)
- `>>=` (右移赋值)

## 最长匹配测试

测试词法分析器能否正确应用最长匹配原则：

| 输入 | 应识别为 | 说明 |
|------|---------|------|
| `<` | `<` (编号68) | 单字符 |
| `<=` | `<=` (编号71) | 双字符，不是 `<` + `=` |
| `<<` | `<<` (编号69) | 双字符 |
| `<<=` | `<<=` (编号70) | 三字符，不是 `<<` + `=` |

## 边界情况测试

```c
a+++++b
```

应识别为：`a` `++` `++` `+` `b`（最长匹配原则）

而不是：`a` `+` `+` `+` `+` `+` `b`

## 编译和运行

```bash
cd operator_test
g++ -std=c++11 -o operator_test operator_test.cpp
./operator_test
```

## 输出示例

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
运算符识别测试程序
测试最长匹配原则
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

测试组 1: 最长匹配原则
─────────────────────────────────────
  输入: "<=" - 小于等于
  期望: 双字符 <=
  结果: 1: <<=,71>
  ✓ 通过

...

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
测试统计
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
通过测试: 25/25
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

## 技术要点

1. **向前查看（Lookahead）**：
   - 读取第一个字符后，需查看下一个字符
   - 决定是单字符还是多字符运算符

2. **贪婪匹配**：
   - 优先匹配更长的运算符
   - 例如：遇到`<`后检查是否为`<=`或`<<=`

3. **状态转换**：
   - 每种运算符对应一个DFA分支
   - 根据当前字符和下一个字符决定状态转换

## 算法示例

```
输入: <<=

状态0: 读取 '<'
  ↓ 向前看下一个字符
状态1: 发现 '<'，可能是 '<<'
  ↓ 继续向前看
状态2: 发现 '='，确定为 '<<='
  ↓ 返回 Token("<<=", 70)
```
